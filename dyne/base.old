"""
Classes for defining the generic pipes for the pipeline

Created by: Ankit Khambhati

Change Log
----------
2016/03/02 - Established the BasePipe with hash naming convention
"""
# Author: Ankit Khambhati
# License: BSD 3-Clause


from functools import wraps

import json
import inspect

import display
import exceptions
import errors


def coroutine(func):
    """Advance a coroutine to first yield point"""

    @wraps(func)
    def start(*args, **kwargs):
        cr = func(*args, **kwargs)
        next(cr)
        return cr
    return start


class BasePipe(object):
    """
    Base class for all pipes in DyNe

    Rules
    -----
        1. All derived pipe classes must explicitly define all pipe parameters
           as variable names in __init__
        2. No *args or **kwargs may be used
    """

    @classmethod
    def _get_param_var(cls):
        """Return parameters specified by __init__ method of the class"""

        all_param_var = inspect.getargspec(cls.__init__)[0]
        return [param for param in all_param_var if not param == 'self']


    def to_JSON(self):
        """Return JSON dictionary of pipe parameters"""

        param_dict = {}
        for param in self._get_param_var():
            param_dict[param] = self.__dict__[param]
        return json.dumps(param_dict, sort_keys=True)


    def __repr__(self):
        class_name = self.__class__.__name__
        return '%s(%s)' % (class_name,
                          display.pprint(self.__dict__, offset=len(class_name)))


    @classmethod
    def get_valid_link(self):
        """Return list of pipe types the current pipe type can link to"""

        raise NotImplementedError('Must return list of pipe types' +
                                  ' the current pipe type can connect to')


    def link(self, downstream_pipe):
        """
        Link the current pipe to a downstream pipe
        """

        if downstream_pipe:
            check_pipe_type = [isinstance(downstream_pipe, val_pipe_type)
                               for val_pipe_type in self.get_valid_link()]
            if not any(check_pipe_type):
                raise exceptions.PipeLinkError(
                    '%r must be one of the following pipe types: %r' %
                    (downstream_pipe, val_pipe_type))
        self.downstream_pipe = downstream_pipe


    def apply_pipe_as_source(self):
        """Run the pipe as a source"""

        try:
            self._pipe_as_source
        except AttributeError:
            raise NotImplementedError(
                '%r does not have _pipe_as_source implemented' %
                self.__class__.__name__)

        while True:

            # Target case handling
            if self.target:
                self.print_pipe_start(opt=str(signal_packet['time']))
                self.target.apply().send(signal_packet)
            else:
                self.print_pipe_end(opt=str(signal_packet['time']))
                yield signal_packet


    @coroutine
    def apply_pipe_as_flow(self):
        """Run the pipe as a flow"""

        try:
            self._pipe_as_flow
        except AttributeError:
            raise NotImplementedError(
                '%r does not have _pipe_as_flow implemented' %
                self.__class__.__name__)


    def _verify_signal_packet(self, signal_packet):
        """Signal packet must conform to organization prescribed by pipe type"""

        raise NotImplementedError(
            '%r does not have _verify_signal_packet implemented' %
            self.__class__.__name__)


class InterfacePipe(BasePipe):
    """
    Pipe Type: InterfacePipe

    Yields
    ------
        signal_packet: dict
            1) data: numpy.ndarray, shape: [n_sample x n_node]
                Windowed signal
            2) meta: dict
                i. ax_0: dict
                    a. label: str
                        Describes unit of measurement for n_sample
                    b. index: numpy.ndarray
                        Time stamp for each sample
                ii. ax_1: dict
                    a. label: str
                        Describes what n_node represents
                    b. index: numpy.ndarray
                        String label for each node

    Linkable pipe types:
        None
        SigprocPipe
        SurrogatePipe
        AssociationPipe
    """

    def _verify_signal_packet(self, signal_packet):
        """Ensure signal packet is organized properly"""

        errors.check_has_key(signal_packet, 'data')
        errors.check_has_key(signal_packet, 'meta')
        errors.check_has_key(signal_packet['meta'], 'ax_0')
        errors.check_has_key(signal_packet['meta'], 'ax_1')
        errors.check_has_key(signal_packet['meta']['ax_0'], 'label')
        errors.check_has_key(signal_packet['meta']['ax_0'], 'index')
        errors.check_has_key(signal_packet['meta']['ax_1'], 'label')
        errors.check_has_key(signal_packet['meta']['ax_1'], 'index')

        errors.check_type(signal_packet['data'], np.ndarray)
        errors.check_type(signal_packet['meta']['ax_0']['label'], str)
        errors.check_type(signal_packet['meta']['ax_0']['index'], np.ndarray)
        errors.check_type(signal_packet['meta']['ax_1']['label'], str)
        errors.check_type(signal_packet['meta']['ax_1']['index'], np.ndarray)


# Define Post-Adjacency pipes
class EdgemetricPipe(BasePipe):
    """
    Pipeline class for EDGEMETRIC Pipe

    Piping Interface:
        EDGEMETRIC --> None
        EDGEMETRIC --> EDGEMETRIC
    """


    def branch(self):
        pass


    def apply(self):
        """
        Apply an EDGEMETRIC Pipe

        Inputs
        ------
        signal_packet: dict
            A dictionary containing:
                1) time: float
                    Leading edge time of the window (seconds)
                2) adj: ndarray, shape[n_node x n_node]
                    Statistically significant adjacency matrix
                3) cache_path: str
                    Base cache path to store pipe results in HDF5

        Yields
        ------
        signal_packet: dict
            A dictionary containing:
                1) time: float
                    Leading edge time of the window (seconds)
                2) metric: ndarray, shape[1 x n_edges]
                    Applied measure corresponding to each network edge
                3) cache_path: str
                    Base cache path to store pipe results in HDF5
        """

        super(EdgemetricPipe, self).apply()

        # Loop as long as pipeline is active
        while True:
            signal_packet = (yield)

            # Check packet
            try:
                signal_packet['adj']
                signal_packet['time']
                cache_path = signal_packet['cache_path']
            except KeyError:
                raise Exception('signal_packet has incorrect dictionary')

            # Perform _func_def
            metric = self._func_def(signal_packet)
            signal_packet['metric'] = metric.reshape(1, -1)

            # Add/remove from signal_packet
            signal_packet.pop('adj', None)

            # Write to cache
            if self.cache:
                # Initialize cache
                try:
                    self.cache_df
                except AttributeError:
                    self.cache_df = h5py.File(
                        cache_path+self.pipe_name+'.hdf', 'w')
                write_pipe_cache(self.cache_df, signal_packet)

            # Write to log
            try:
                self.stdout
            except AttributeError:
                self.stdout = open(cache_path+self.pipe_name+'.out', 'w')
            write_pipe_log(self.stdout, signal_packet)

            # Target case handling
            if self.target:
                self.print_pipe_connect()
                self.target.apply().send(signal_packet)
            else:
                self.print_pipe_end()
                yield signal_packet

        # Close cache
        if self.cache:
            self.cache_df.close()

        # Close log
        self.stdout.write('DONE')
        self.stdout.flush()
        self.stdout.close()


class NodemetricPipe(BasePipe):
    """
    Pipeline class for NODEMTRIC Pipe

    Piping Interface:
        NODEMETRIC --> None
        NODEMETRIC --> NODEMETRIC
    """


    def branch(self):
        pass


    def apply(self):
        """
        Apply an NODEMETRIC Pipe

        Inputs
        ------
        signal_packet: dict
            A dictionary containing:
                1) time: float
                    Leading edge time of the window (seconds)
                2) adj: ndarray, shape[n_node x n_node]
                    Statistically significant adjacency matrix
                3) cache_path: str
                    Base cache path to store pipe results in HDF5

        Yields
        ------
        signal_packet: dict
            A dictionary containing:
                1) time: float
                    Leading edge time of the window (seconds)
                2) metric: ndarray, shape[1 x n_node]
                    Applied measure to each network node
                3) cache_path: str
                    Base cache path to store pipe results in HDF5
        """

        super(NodemetricPipe, self).apply()

        # Loop as long as pipeline is active
        while True:
            signal_packet = (yield)

            # Check packet
            try:
                signal_packet['adj']
                signal_packet['time']
                cache_path = signal_packet['cache_path']
            except KeyError:
                raise Exception('signal_packet has incorrect dictionary')

            # Perform _func_def
            metric = self._func_def(signal_packet)
            signal_packet['metric'] = metric.reshape(1, -1)

            # Add/remove from signal_packet
            signal_packet.pop('adj', None)

            # Write to cache
            if self.cache:
                # Initialize cache
                try:
                    self.cache_df
                except AttributeError:
                    self.cache_df = h5py.File(
                        cache_path+self.pipe_name+'.hdf', 'w')
                write_pipe_cache(self.cache_df, signal_packet)

            # Write to log
            try:
                self.stdout
            except AttributeError:
                self.stdout = open(cache_path+self.pipe_name+'.out', 'w')
            write_pipe_log(self.stdout, signal_packet)

            # Target case handling
            if self.target:
                self.print_pipe_connect()
                self.target.apply().send(signal_packet)
            else:
                self.print_pipe_end()
                yield signal_packet

        # Close cache
        if self.cache:
            self.cache_df.close()

        # Close log
        self.stdout.write('DONE')
        self.stdout.flush()
        self.stdout.close()


class NetvizPipe(BasePipe):
    """
    Pipeline class for NETVIZ Pipes

    Piping Interface:
        NETVIZ --> None
        NETVIZ --> NETVIZ
    """


    def branch(self):
        pass


    def apply(self):
        """
        Apply an NETVIZ Pipe

        Inputs
        ------
        signal_packet: dict
            A dictionary containing:
                1) time: float
                    Leading edge time of the window (seconds)
                2) adj: ndarray, shape[n_node x n_node]
                    Statistically significant adjacency matrix
                3) cache_path: str
                    Base cache path to store pipe results in HDF5

        Yields
        ------
        signal_packet: dict
            A dictionary containing:
                1) time: float
                    Leading edge time of the window (seconds)
                2) adj: ndarray, shape[n_node x n_node]
                    Statistically significant adjacency matrix
                3) cache_path: str
                    Base cache path to store pipe results in HDF5
        """

        super(NetvizPipe, self).apply()

        # Loop as long as pipeline is active
        while True:
            signal_packet = (yield)

            # Check packet
            try:
                adj = signal_packet['adj']
                time = signal_packet['time']
            except KeyError:
                raise Exception('signal_packet has incorrect dictionary')

            # Perform _func_def
            self._func_def(adj, time)

            # Target case handling
            if self.target:
                self.print_pipe_connect()
                self.target.apply().send(signal_packet)
            else:
                self.print_pipe_end()
                yield signal_packet


# Define Pre-Adjacency pipes
class AdjacencyPipe(BasePipe):
    """
    Pipeline class for ADJACENCY Pipes

    Piping Interface:
        ADJACENCY --> None
        ADJACENCY --> NETVIZ
    """

    def branch(self, cache_path, branch_path):
        """
        Generator function to iterate through cached pipe data

        Yields
        ------
        signal_packet: dict
            A dictionary containing:
                1) time: float
                    Leading edge time of the window (seconds)
                2) adj: ndarray, shape[n_node x n_node]
                    Statistically significant adjacency matrix
        """
        super(AdjacencyPipe, self).apply()

        # Initialize generator
        self.branch_df_ = h5py.File(branch_path, 'r')
        gen = get_pipe_cache(self.branch_df_)

        # Stream pipe cache data
        while True:
            signal_packet = gen.next()

            # Check packet
            try:
                signal_packet['time']
                signal_packet['adj']
            except KeyError:
                raise Exception('signal_packet has incorrect dictionary')
            signal_packet['cache_path'] = cache_path

            # Target case handling
            if self.target:
                self.print_pipe_start(opt=str(signal_packet['time']))
                self.target.apply().send(signal_packet)
            else:
                self.print_pipe_end(opt=str(signal_packet['time']))
                yield signal_packet
            self.print_pipe_loop()

        # Close cache
        self.branch_df_.close()


    def apply(self):
        """
        Apply an ADJACENCY Pipe

        Inputs
        ------
        signal_packet: dict
            A dictionary containing:
                1) fs: float
                    Sampling frequency of signal window samples
                2) time: float
                    Leading edge time of the window (seconds)
                3) win: ndarray, shape: [n_sample_win x n_node]
                    Windowed signal
                4) surr_win: ndarray, (*optional*)
                             shape: [n_total_surrogate x n_sample_win x n_node]
                    Filtered windowed signal
                5) cache_path: str
                    Base cache path to store pipe results in HDF5

        Attributes
        ----------
        cache_df_: h5py.File
            HDF5 file object in which to cache pipe data

        Yields
        ------
        signal_packet: dict
            A dictionary containing:
                1) time: float
                    Leading edge time of the window (seconds)
                2) adj: ndarray, shape[n_node x n_node]
                    Statistically significant adjacency matrix
                3) cache_path: str
                    Base cache path to store pipe results in HDF5
        """
        super(AdjacencyPipe, self).apply()

        # Loop as long as pipeline is active
        while True:
            signal_packet = (yield)

            # Apply to real windowed signal / Update signal_packet
            try:
                signal_packet['fs']
                signal_packet['time']
                signal_packet['win']
                cache_path = signal_packet['cache_path']
            except KeyError:
                raise Exception('signal_packet has incorrect dictionary')
            adj = self._func_def(signal_packet)
            signal_packet['adj'] = adj

            # Add/remove from signal_packet
            signal_packet.pop('win', None)
            signal_packet.pop('surr_win', None)
            signal_packet.pop('fs', None)

            # Write to cache
            if self.cache:
                # Initialize cache
                try:
                    self.cache_df
                except AttributeError:
                    self.cache_df = h5py.File(
                        cache_path+self.pipe_name+'.hdf', 'w')
                write_pipe_cache(self.cache_df, signal_packet)

            # Write to log
            try:
                self.stdout
            except AttributeError:
                self.stdout = open(cache_path+self.pipe_name+'.out', 'w')
            write_pipe_log(self.stdout, signal_packet)

            # Target case handling
            if self.target:
                self.print_pipe_connect()
                self.target.apply().send(signal_packet)
            else:
                self.print_pipe_end()
                yield signal_packet

        # Close cache
        if self.cache:
            self.cache_df.close()

        # Close log
        self.stdout.write('DONE')
        self.stdout.flush()
        self.stdout.close()


class SurrogatePipe(BasePipe):
    """
    Pipeline class for SURROGATE Pipes

    Piping Interface:
        SURROGATE --> None
        SURROGATE --> ASSOCIATION
    """
    __metaclass__ = ABCMeta

    def branch(self, cache_path, branch_path):
        """
        Generator function to iterate through cached pipe data

        Yields
        ------
        signal_packet: dict
            A dictionary containing:
                1) fs: float
                    Sampling frequency of signal window samples
                2) time: float
                    Leading edge time of the window (seconds)
                3) win: ndarray, shape: [n_sample_win x n_node]
                    Windowed signal
                4) surr_win: ndarray,
                             shape: [n_total_surrogate x n_sample_win x n_node]
                    Surrogate transformed windowed signal
            """
        super(SurrogatePipe, self).apply()

        # Initialize generator
        self.branch_df_ = h5py.File(branch_path, 'r')
        gen = get_pipe_cache(self.branch_df_)

        # Stream pipe cache data
        while True:
            signal_packet = gen.next()

            # Check packet
            try:
                signal_packet['fs']
                signal_packet['time']
                signal_packet['win']
                signal_packet['surr_win']
            except KeyError:
                raise Exception('signal_packet has incorrect dictionary')
            signal_packet['cache_path'] = cache_path

            # Target case handling
            if self.target:
                self.print_pipe_start(opt=str(signal_packet['time']))
                self.target.apply().send(signal_packet)
            else:
                self.print_pipe_end(opt=str(signal_packet['time']))
                yield signal_packet
            self.print_pipe_loop()

        # Close cache
        self.branch_df_.close()


    def apply(self):
        """
        Apply a SURROGATE Pipe

        Inputs
        ------
        signal_packet: dict
            A dictionary containing:
                1) fs: float
                    Sampling frequency of signal window samples
                2) time: float
                    Leading edge time of the window (seconds)
                3) win: ndarray, shape: [n_sample_win x n_node]
                    Windowed signal
                4) cache_path: str
                    Base cache path to store pipe results in HDF5

        Attributes
        ----------
        cache_df_: h5py.File
            HDF5 file object in which to cache pipe data

        Yields
        ------
        signal_packet: dict
            A dictionary containing:
                1) fs: float
                    Sampling frequency of signal window samples
                2) time: float
                    Leading edge time of the window (seconds)
                3) win: ndarray, shape: [n_sample_win x n_node]
                    Windowed signal
                4) surr_win: ndarray,
                             shape: [n_total_surrogate x n_sample_win x n_node]
                    Surrogate transformed windowed signal
                5) cache_path: str
                    Base cache path to store pipe results in HDF5
        """
        super(SurrogatePipe, self).apply()

        # Loop as long as pipeline is active
        while True:
            signal_packet = (yield)

            try:
                signal_packet['fs']
                signal_packet['time']
                signal_packet['win']
                cache_path = signal_packet['cache_path']
            except KeyError:
                raise Exception('signal_packet has incorrect dictionary')

            # Do computation / Update signal_packet
            signal_packet = self._func_def(signal_packet)

            # Write to cache
            if self.cache:
                # Initialize cache
                try:
                    self.cache_df
                except AttributeError:
                    self.cache_df = h5py.File(
                        cache_path+self.pipe_name+'.hdf', 'w')
                write_pipe_cache(self.cache_df, signal_packet)

            # Write to log
            try:
                self.stdout
            except AttributeError:
                self.stdout = open(cache_path+self.pipe_name+'.out', 'w')
            write_pipe_log(self.stdout, signal_packet)

            # Target case handling
            if self.target:
                self.print_pipe_connect()
                self.target.apply().send(signal_packet)
            else:
                self.print_pipe_end()
                yield signal_packet

        # Close cache
        if self.cache:
            self.cache_df.close()

        # Close log
        self.stdout.write('DONE')
        self.stdout.flush()
        self.stdout.close()


class SigprocPipe(BasePipe):
    """
    Pipeline class for SIGPROC Pipes

    Piping Interface:
        SIGPROC --> None
        SIGPROC --> SIGPROC
        SIGPROC --> SURROGATE
        SIGPROC --> ASSOCIATION
    """
    __metaclass__ = ABCMeta

    def branch(self, cache_path, branch_path):
        """
        Generator function to iterate through cached pipe data

        Yields
        ------
        signal_packet: dict
            A dictionary containing:
                1) fs: float
                    Sampling frequency of signal window samples
                2) time: float
                    Leading edge time of the window (seconds)
                3) win: ndarray, shape: [n_sample_win x n_node]
                    SIGPROC-Modified windowed signal
                4) cache_path: str
                    Base cache path to store pipe results in HDF5
        """
        super(SigprocPipe, self).apply()

        # Initialize generator
        self.branch_df_ = h5py.File(branch_path, 'r')
        gen = get_pipe_cache(self.branch_df_)

        # Stream pipe cache data
        while True:
            signal_packet = gen.next()

            # Check packet
            try:
                signal_packet['fs']
                signal_packet['time']
                signal_packet['win']
            except KeyError:
                raise Exception('signal_packet has incorrect dictionary')
            signal_packet['cache_path'] = cache_path

            # Target case handling
            if self.target:
                self.print_pipe_start(opt=str(signal_packet['time']))
                self.target.apply().send(signal_packet)
            else:
                self.print_pipe_end(opt=str(signal_packet['time']))
                yield signal_packet
            self.print_pipe_loop()

        # Close cache
        self.branch_df_.close()


    def apply(self):
        """
        Apply a SIGPROC pipe

        Inputs
        ------
        signal_packet: dict
            A dictionary containing:
                1) fs: float
                    Sampling frequency of signal window samples
                2) time: float
                    Leading edge time of the window (seconds)
                3) win: ndarray, shape: [n_sample_win x n_node]
                    Windowed signal
                4) cache_path: str
                    Base cache path to store pipe results in HDF5

        Attributes
        ----------
        cache_df_: h5py.File
            HDF5 file object in which to cache pipe data

        Yields
        ------
        signal_packet: dict
            A dictionary containing:
                1) fs: float
                    Sampling frequency of signal window samples
                2) time: float
                    Leading edge time of the window (seconds)
                3) win: ndarray, shape: [n_sample_win x n_node]
                    SIGPROC-Modified windowed signal
                4) cache_path: str
                    Base cache path to store pipe results in HDF5
        """
        super(SigprocPipe, self).apply()

        # Init
        while True:
            signal_packet = (yield)

            # Check packet
            try:
                signal_packet['fs']
                signal_packet['time']
                signal_packet['win']
                cache_path = signal_packet['cache_path']
            except KeyError:
                raise Exception('signal_packet has incorrect dictionary')

            # Do computation / Update signal_packet
            win = self._func_def(signal_packet)
            signal_packet['win'] = win

            # Write to cache
            if self.cache:
                # Initialize cache
                try:
                    self.cache_df
                except AttributeError:
                    self.cache_df = h5py.File(
                        cache_path+self.pipe_name+'.hdf', 'w')
                write_pipe_cache(self.cache_df, signal_packet)

            # Write to log
            try:
                self.stdout
            except AttributeError:
                self.stdout = open(cache_path+self.pipe_name+'.out', 'w')
            write_pipe_log(self.stdout, signal_packet)

            # Target case handling
            if self.target:
                self.print_pipe_connect()
                self.target.apply().send(signal_packet)
            else:
                self.print_pipe_end()
                yield signal_packet

        # Close cache
        if self.cache:
            self.cache_df.close()

        # Close log
        self.stdout.write('DONE')
        self.stdout.flush()
        self.stdout.close()





# Caching pipe results
def write_pipe_log(std, signal_packet):
    """
    Write the signal_packet contents to the pipe cache for a given pipe

    Parameters
    ----------
    std: File handle object
        Text file object in which to log pipe status

    signal_packet: dict
        Containing objects to cache
    """
    std.write('Proc -- %0.3f (sec) | \n' % signal_packet['time'])
    std.flush()


def write_pipe_cache(df, signal_packet):
    """
    Write the signal_packet contents to the pipe cache for a given pipe

    Parameters
    ----------
    df: h5py.File
        HDF5 file object in which to cache pipe data

    signal_packet: dict
        Containing objects to cache
    """
    assert type(signal_packet) == dict
    assert type(df) == h5py._hl.files.File

    for key in signal_packet:
        key_item = signal_packet[key]
        if type(key_item) is np.float64:
            try:
                dset = df[key]
            except KeyError:
                dset = df.require_dataset(
                    key,
                    (0, 1),
                    np.float,
                    maxshape=(None, 1),
                    compression='lzf')
            dset.resize(dset.shape[0]+1, axis=0)
            dset[-1, 0] = key_item

        if type(key_item) is np.ndarray:
            try:
                dset = df[key]
            except KeyError:
                dset = df.require_dataset(
                    key,
                    (0,)+key_item.shape,
                    np.float,
                    maxshape=(None,)+key_item.shape,
                    compression='lzf')
            dset.resize(dset.shape[0]+1, axis=0)
            dset[-1, ...] = key_item

    df.flush()


def get_pipe_cache(df):
    """
    Get the pipe cache contents and store in signal_packet dictionary

    Parameters
    ----------
    df: h5py.File
        HDF5 file object from which to retrieve cache pipe data
    """
    assert type(df) == h5py._hl.files.File

    idx = 0
    while True:
        signal_packet = {}
        try:
            for key in df:
                signal_packet[key] = df[key][idx, ...]
            yield signal_packet
        except ValueError:
            raise StopIteration
        idx += 1
